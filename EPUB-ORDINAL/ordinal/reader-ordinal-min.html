<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"><title>A CHRISTMAS CAROL</title><style>:root{--bg:#222;--fg:#eee;--sidebar-bg:#333;--shadow:rgba(0, 0, 0, 0.3);--accent:#d4a373;--meta-label:#999;--spinner-color:#3498db}body.light{--bg:#fff;--fg:#222;--sidebar-bg:#f5f5f5;--shadow:rgba(0, 0, 0, 0.1);--accent:#d4a373;--meta-label:#666;--spinner-color:#3498db}*{-webkit-tap-highlight-color:transparent;overscroll-behavior:none}html{touch-action:manipulation;overscroll-behavior:none}body{margin:0;font:16px/1.6 Georgia,serif;background:var(--bg);color:var(--fg);-webkit-text-size-adjust:none;touch-action:manipulation;overflow-y:auto;overscroll-behavior:none}button{touch-action:manipulation;-webkit-touch-callout:none}#content{display:flex;min-height:100vh;position:relative;overscroll-behavior:none}#sidebar{width:300px;background:var(--sidebar-bg);box-shadow:2px 0 5px var(--shadow);position:fixed;top:0;left:0;bottom:0;padding:20px;overflow-y:auto;z-index:1000;transform:translateX(-100%);transition:transform .3s}#sidebar.active{transform:translateX(0);box-shadow:0 0 15px var(--shadow)}#reader{flex:1;position:relative;display:flex;flex-direction:column;touch-action:pan-y pinch-zoom;-webkit-overflow-scrolling:touch}#reader.book-mode{overflow-y:auto;-webkit-overflow-scrolling:touch;display:flex;justify-content:center;align-items:center;padding:4em 2em;min-height:100vh}#reader:not(.book-mode){padding:1em;padding-bottom:6em;max-width:800px;margin:0 auto;height:auto;min-height:auto;overflow:visible}#reader-content{width:100%;flex:1;display:flex;flex-direction:column}#chapters{width:100%;display:flex;flex-direction:column;gap:2em;padding-bottom:4em}#chapters.book-mode{display:flex;flex-direction:column;max-width:min(1260px,85vw);width:100%;height:min(85vh,95vh);max-height:1100px;margin:0 auto;overflow:hidden}.chapter{display:none;width:100%;min-height:auto;height:min(80vh,85vh);max-height:1100px;padding:0;margin:0;background:var(--sidebar-bg);box-shadow:0 0 10px var(--shadow);border-radius:2px;font-family:Georgia,serif;line-height:1.5;font-size:var(--font-size,1em);box-sizing:border-box;flex-direction:column;margin-bottom:2em}.chapter.active{display:flex;flex-direction:row;flex-wrap:wrap;background:var(--sidebar-bg);padding:0;width:100%;height:100%;gap:0;overflow:hidden}.chapter:first-child{justify-content:center;align-items:center;text-align:center}.chapter:first-child .page{display:flex!important;justify-content:center;align-items:center;text-align:center}.chapter:first-child .page>*{margin:0}.chapter:only-child h1{margin:auto}.chapter>:first-child{margin-top:0}.chapter>:last-child{margin-bottom:0}.chapter img{max-width:100%;height:auto}.chapter h1{color:var(--accent);font-size:1.8em;margin:0 0 1em 0}.page-spread{display:none;width:100%;height:100%}.page-spread.active{display:flex;flex-direction:row;gap:0}.page{flex:1;width:50%;min-width:50%;height:100%;max-height:100%;padding:1.5em;background:var(--sidebar-bg);box-shadow:2px 0 5px var(--shadow);box-sizing:border-box;display:none;margin:0;overflow-y:auto;text-align:justify;line-height:1.5;color:var(--fg);touch-action:pan-y;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;-webkit-overflow-scrolling:touch}.page.active{display:block;padding:40px!important}.page:nth-child(odd).active{border-right:1px solid var(--shadow)}.page>*{margin-bottom:1em}.page>:last-child{margin-bottom:0}.page p{margin:.2em 0;text-align:justify}.meta{margin:.5em 0 1em 0;font-size:.85em}.meta div{margin:.5em 0;line-height:1.4}.meta-label{font-size:.75em;text-transform:uppercase;letter-spacing:.05em;color:#666;margin-bottom:.2em;font-size:.8em;color:var(--fg);opacity:.7;margin-bottom:2px}.meta-value{font-size:.9em;font-size:.9em;color:var(--accent)}.toc-item{padding:.5em 0;cursor:pointer;border-bottom:1px solid var(--shadow);font-size:.9em}.toc-item:hover{color:var(--accent)}.toc-item.active{color:var(--accent);font-weight:700}#debug{padding:.5em;font-size:.75em;color:#666;border-bottom:1px solid var(--shadow)}#progress{position:fixed;bottom:50px;left:0;right:0;height:3px;background:var(--shadow)}#progress-bar{height:100%;width:0;background:var(--accent);transition:width .3s}.menu-controls{position:fixed;top:20px;right:20px;z-index:10}.menu-trigger{padding:0;background:0 0;border:none;color:var(--accent);cursor:pointer;font-size:2em;border-left:1px solid var(--shadow);opacity:.7;transition:opacity .2s;background:0 0;border:none;color:var(--accent);cursor:pointer;padding:4px;border-radius:4px;transition:.2s}.menu-trigger.active,.menu-trigger:hover{opacity:1}.menu-dropdown{position:absolute;right:5px;background:var(--sidebar-bg);box-shadow:0 2px 8px var(--shadow);padding:5px;display:none;min-width:180px;position:absolute;top:calc(100% + 8px);right:0;background:var(--sidebar-bg);border-radius:4px;box-shadow:0 2px 8px var(--shadow);min-width:200px;display:none}.menu-dropdown.active{display:block}.menu-group{padding:8px;border-bottom:1px solid var(--shadow);padding:12px;border-bottom:1px solid var(--shadow)}.menu-group:last-child{border-bottom:none;border:none}.menu-group-title{font-size:.8em;color:var(--fg);opacity:.7;margin-bottom:8px}.nav-button{display:block;width:100%;text-align:left;padding:8px;border:none;background:0 0;color:var(--fg);cursor:pointer;border-radius:4px;transition:.2s}.nav-button:hover{background:var(--shadow)}.nav-button.active{background:var(--accent);color:var(--sidebar-bg)}.font-controls{display:flex;gap:8px}.font-size-btn{padding:4px 8px;border:1px solid var(--shadow);border-radius:4px;background:0 0;color:var(--fg);cursor:pointer}.font-size-btn:hover{background:var(--shadow)}.side-nav{position:fixed;top:50%;transform:translateY(-50%);z-index:4;opacity:.3;transition:opacity .2s}.side-nav.prev{left:20px}.side-nav.next{right:20px}.side-nav .nav-button{font-size:1.5em;padding:15px;background:0 0;border:none;color:var(--accent);cursor:pointer;transition:transform .2s}.side-nav:hover{opacity:.8}.side-nav .nav-button:hover{transform:scale(1.2);background:0 0;color:var(--accent)}#mobile-nav{display:none;position:fixed;bottom:0;left:0;width:100%;background:var(--sidebar-bg);box-shadow:0 -2px 5px var(--shadow);z-index:10}#mobile-nav.expanded{transform:translateY(0);height:auto;max-height:70vh;overflow-y:auto}.nav-content{display:none;padding:15px;border-top:1px solid var(--shadow);background:var(--sidebar-bg);border-top:1px solid var(--shadow);padding:15px}#mobile-nav.expanded .nav-content{display:block}.book-info{position:fixed;top:0;right:0;transform:none;background:0 0;padding:0 10px;border-radius:4px;font-size:.9em;display:flex;gap:15px;align-items:center;z-index:5}.book-info .title{display:none}.book-info .chapter{opacity:.8}.book-info .pages{padding-left:15px}.book-info:hover{opacity:1}#meta{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:15px;margin-bottom:15px}#toc{max-height:300px;overflow-y:auto;border-top:1px solid var(--shadow);padding-top:15px}#reader:not(.book-mode) .chapter{padding:1.5em;padding-bottom:8em;margin-bottom:2em;text-align:left;line-height:1.6;background:0 0;box-shadow:none;height:auto;min-height:auto;display:block;overflow:visible}#reader:not(.book-mode) .chapter:last-child{margin-bottom:12em}#reader:not(.book-mode) .page{height:auto;min-height:auto;width:100%;max-width:100%;padding:0;margin:0;box-shadow:none;overflow:visible;display:block}#reader:not(.book-mode){padding-bottom:4em}body:has(#reader:not(.book-mode)) .book-info .pages,body:has(#reader:not(.book-mode)) .side-nav{display:none!important}@media (max-width:1024px){.page{width:50%;min-width:50%;max-width:50%;padding:1em}.side-nav{display:flex}}@media (max-width:800px){#mobile-nav{display:block}.chapter.active{flex-direction:column;margin-top:3.2em}.page{width:100%;min-width:100%;max-width:100%;height:auto;min-height:calc(100vh - 80px);max-height:none;box-sizing:border-box;font-size:1em;line-height:1.4;padding:20px!important;overflow-y:visible}.page *{max-width:100%;overflow-wrap:break-word;word-wrap:break-word;hyphens:auto}.page p{margin:.3em 0;width:100%;max-width:100%;text-align:justify}#chapters.book-mode{max-width:100%;width:100%;height:auto;min-height:calc(100vh - 2em);padding:0;margin:0;box-sizing:border-box}#reader.book-mode{padding:0;height:auto;min-height:100vh;margin:0;box-sizing:border-box}.page.active+.page.active{display:none}.side-nav{transform:scale(.7);opacity:.9}.side-nav.prev{left:0}.side-nav.next{right:0}#reader:not(.book-mode){padding:1em;padding-bottom:6em;overflow:visible}#reader:not(.book-mode) .chapter{padding:1.5em;padding-bottom:8em;overflow:visible}#reader:not(.book-mode) .chapter:last-child{margin-bottom:8em}#chapters{padding-bottom:2em}body{overflow-y:visible}.page-spread.active{padding:0}}#loading-spinner{position:fixed;top:0;left:0;width:100%;height:100%;background:var(--bg);display:flex;justify-content:center;align-items:center;z-index:1000}.spinner{width:20px;height:20px;border:2px solid rgba(255,255,255,.1);border-top:2px solid var(--accent);border-radius:50%;animation:spin .8s linear infinite}@keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}body.light #loading-spinner{background:var(--bg)}body.light .spinner{border-color:rgba(0,0,0,.1);border-top-color:var(--accent)}</style></head><body><div id="content"><div id="sidebar"><input type="file" accept=".epub" id="fileInput"><div id="meta"></div><div id="debug"></div><div id="toc"></div></div><div id="reader"><div id="reader-content"><div class="upload-area"><input type="file" accept=".epub" id="mainFileInput" style="display:none"></div><div id="chapters"></div></div></div><div class="book-info"><span class="pages" id="page-info"></span><button class="menu-trigger" onclick="toggleMenu()">‚ò∞</button><div class="menu-dropdown"><div class="menu-group"><button class="nav-button book" onclick="toggleBookMode()">üìö Book Mode</button><button class="nav-button theme" onclick='document.body.classList.toggle("light")'>‚òÄÔ∏è Theme</button></div><div class="menu-group"><div class="menu-group-title">Book Info</div><div id="book-meta"></div></div></div></div><div id="loading-spinner" style="display:none"><div class="spinner"></div></div></div><div class="side-nav prev"><button class="nav-button prev" onclick="prevPage()">‚ùÆ</button></div><div class="side-nav next"><button class="nav-button next" onclick="nextPage()">‚ùØ</button></div><script src="https://ordinals.com/content/372c5388030820daed356d25d7a1218d0b88d78a6d051d27c91d0f25ac4c3c5ei0"></script><script>async function readEpub(blob) {
  const zip = new JSZip();
  await zip.loadAsync(blob);
  
  console.log("Files in ZIP:", Object.keys(zip.files));
  
  // Get metadata from OPF
  const container = await zip.file("META-INF/container.xml").async("text");
  const opfPath = container.match(/full-path="([^"]+)"/)?.[1];
  if (!opfPath) throw new Error("Invalid EPUB");
  
  const opf = await zip.file(opfPath).async("text");
  const parser = new DOMParser();
  const doc = parser.parseFromString(opf, "text/xml");

  // Get metadata
  const meta = {};
  ["title", "creator", "language", "date", "identifier"].forEach(tag => {
    meta[tag] = doc.querySelector(`dc\\:${tag}, ${tag}`)?.textContent?.trim();
  });

  // Find all HTML/XHTML files in the ZIP
  const allFiles = Object.keys(zip.files);
  console.log("All files:", allFiles);

  const htmlFiles = allFiles.filter(path => 
    path.match(/\.(x?html?|htm)$/i) && 
    !path.startsWith('__MACOSX') &&
    !zip.files[path].dir
  );
  console.log("HTML files found:", htmlFiles);

  // Load all HTML files as chapters
  const chapters = [];
  for (const path of htmlFiles) {
    try {
      const content = await zip.file(path).async("text");
      if (content && content.trim()) {
        console.log(`Content found in ${path}, length: ${content.length}`);
        chapters.push({
          id: path,
          content: content
        });
      }
    } catch (err) {
      console.error(`Error loading ${path}:`, err);
    }
  }

  // If no HTML files found, try XML files
  if (chapters.length === 0) {
    const xmlFiles = allFiles.filter(path => 
      path.match(/\.xml$/i) && 
      !path.startsWith('__MACOSX') &&
      !path.includes('container.xml') &&
      !zip.files[path].dir
    );
    
    for (const path of xmlFiles) {
      try {
        const content = await zip.file(path).async("text");
        if (content && content.trim()) {
          console.log(`Content found in ${path}, length: ${content.length}`);
          chapters.push({
            id: path,
            content: content
          });
        }
      } catch (err) {
        console.error(`Error loading ${path}:`, err);
      }
    }
  }

  console.log(`Total chapters found: ${chapters.length}`);

  // Create simple TOC
  const toc = chapters.map((ch, i) => ({
    id: ch.id,
    title: `Chapter ${i + 1}`,
    src: null
  }));

  return { meta, chapters, toc, css: [] };
}</script><script>// Add font size control
    let currentFontSize = 1;
    
    function adjustFontSize(delta) {
      currentFontSize = Math.max(0.8, Math.min(1.5, currentFontSize + delta));
      document.documentElement.style.setProperty('--font-size', `${currentFontSize}em`);
      
      if (els.reader.classList.contains('book-mode')) {
        convertToPages();
        showChapter(currentChapter, currentPage);
      }
    }

    const els = {
      fileInput: document.getElementById('fileInput'),
      mainFileInput: document.getElementById('mainFileInput'),
      uploadArea: document.querySelector('.upload-area'),
      meta: document.getElementById('meta'),
      chapters: document.getElementById('chapters'),
      toc: document.getElementById('toc'),
      debug: document.getElementById('debug'),
      sidebar: document.getElementById('sidebar'),
      progressBar: document.getElementById('progress-bar'),
      reader: document.getElementById('reader'),
      pageInfo: document.getElementById('page-info'),
      prevButton: document.querySelector('.nav-button.prev'),
      nextButton: document.querySelector('.nav-button.next')
    };

    let currentChapter = 0;
    let totalChapters = 0;
    let currentPage = 0;

    // Mobile touch handling
    let touchStartX = 0;
    let touchStartY = 0;
    document.addEventListener('touchstart', e => {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    });
    document.addEventListener('touchend', e => {
      const diffX = touchStartX - e.changedTouches[0].clientX;
      const diffY = touchStartY - e.changedTouches[0].clientY;

      if (Math.abs(diffY) > Math.abs(diffX)) {
        // Vertical scroll, do nothing
        return;
      }

      const swipeThreshold = 100; // Adjust as needed
      if (Math.abs(diffX) > swipeThreshold) {
        if (diffX > 0) {
          nextPage();
        } else {
          prevPage();
        }
      }
    });

    function showChapter(idx, pageIdx = 0) {
      if (idx < 0 || idx >= totalChapters) return;
      
      const chapters = [...els.chapters.children];
      const currentChapterEl = chapters[idx];
      const pages = [...currentChapterEl.querySelectorAll('.page')];
      const isMobile = window.innerWidth <= 800;
      
      chapters.forEach(ch => ch.classList.remove('active'));
      currentChapterEl.classList.add('active');
      
      // Hide all pages
      pages.forEach(page => page.classList.remove('active'));
      
      // Show current page(s)
      if (pages[pageIdx]) {
        pages[pageIdx].classList.add('active');
      }
      if (!isMobile && pages[pageIdx + 1]) {
        pages[pageIdx + 1].classList.add('active');
      }
      
      currentChapter = idx;
      currentPage = pageIdx;
      
      // Calculate total pages across all chapters
      const totalPagesBeforeChapter = chapters
        .slice(0, idx)
        .reduce((sum, ch) => sum + ch.querySelectorAll('.page').length, 0);
      
      const currentPageNumber = totalPagesBeforeChapter + pageIdx + 1;
      const totalPages = chapters.reduce((sum, ch) => sum + ch.querySelectorAll('.page').length, 0);
      
      // Update page info
      const currentPageInfo = isMobile 
        ? `${currentPageNumber}` 
        : `${currentPageNumber}-${Math.min(currentPageNumber + 1, totalPages)}`;
      els.pageInfo.textContent = `${currentPageInfo} of ${totalPages}`;
      
      // Update navigation
      els.prevButton.disabled = currentPageNumber === 1;
      els.nextButton.disabled = isMobile 
        ? currentPageNumber >= totalPages
        : currentPageNumber >= totalPages - 1;
      
      els.progressBar.style.width = `${(currentPageNumber / totalPages) * 100}%`;
      
      els.reader.scrollTop = 0;
    }

    // Update navigation handlers
    function nextPage() {
      const chapter = els.chapters.children[currentChapter];
      const pages = [...chapter.querySelectorAll('.page')];
      const isMobile = window.innerWidth <= 800;
      const increment = isMobile ? 1 : 2;
      
      if (currentPage + increment < pages.length) {
        showChapter(currentChapter, currentPage + increment);
      } else if (currentChapter < totalChapters - 1) {
        showChapter(currentChapter + 1, 0);
      }
    }

    function prevPage() {
      const isMobile = window.innerWidth <= 800;
      const decrement = isMobile ? 1 : 2;
      
      if (currentPage > 0) {
        showChapter(currentChapter, currentPage - decrement);
      } else if (currentChapter > 0) {
        const prevChapter = els.chapters.children[currentChapter - 1];
        const pages = [...prevChapter.querySelectorAll('.page')];
        const lastPageIndex = isMobile ? pages.length - 1 : Math.max(0, pages.length - 2);
        showChapter(currentChapter - 1, lastPageIndex);
      }
    }

    // Update navigation button handlers
    els.nextButton.onclick = () => els.reader.classList.contains('book-mode') ? nextPage() : showChapter(currentChapter + 1);
    els.prevButton.onclick = () => els.reader.classList.contains('book-mode') ? prevPage() : showChapter(currentChapter - 1);

    // Update keyboard navigation
    document.onkeydown = e => {
      if (els.reader.classList.contains('book-mode')) {
        if (e.key === 'ArrowRight') nextPage();
        if (e.key === 'ArrowLeft') prevPage();
      } else {
        if (e.key === 'ArrowRight') showChapter(currentChapter + 1);
        if (e.key === 'ArrowLeft') showChapter(currentChapter - 1);
      }
    };

    // Handle drag and drop
    els.uploadArea.onclick = () => els.mainFileInput.click();
    els.uploadArea.ondragover = e => {
      e.preventDefault();
      els.uploadArea.classList.add('drag-over');
    };
    els.uploadArea.ondragleave = () => els.uploadArea.classList.remove('drag-over');
    els.uploadArea.ondrop = e => {
      e.preventDefault();
      const file = e.dataTransfer.files[0];
      if (file) loadEpub(file);
    };
    els.mainFileInput.onchange = e => loadEpub(e.target.files[0]);
    els.fileInput.onchange = e => loadEpub(e.target.files[0]);

    async function loadEpub(file) {
      try {
        const epub = await readEpub(file);
        els.uploadArea.classList.add('hidden');
        
        // Override metadata with hardcoded values
        epub.meta.title = "A CHRISTMAS CAROL";
        epub.meta.creator = "DICKENS, CHARLES";
        epub.meta.inscriber = "INSCRIPEDIA";
        delete epub.meta.date;
        
        // Define display order
        const displayOrder = ['title', 'creator', 'inscriber', 'language', 'identifier'];
        
        // Update metadata display with custom labels
        const metaContent = displayOrder
          .filter(k => epub.meta[k])
          .map(k => `
            <div class="meta-item">
              <div class="meta-label">${k === 'creator' ? 'AUTHOR' : k === 'inscriber' ? 'PUBLISHER' : k.toUpperCase()}</div>
              <div class="meta-value">${epub.meta[k]}</div>
            </div>
          `).join('');
        
        els.meta.innerHTML = metaContent;
        document.getElementById('book-meta').innerHTML = metaContent;
        
        els.debug.textContent = `Loaded ${epub.chapters.length} chapters`;
        
        els.toc.innerHTML = epub.toc
          .map((item, i) => `<div class="toc-item" onclick="showChapter(${i})">${item.title}</div>`)
          .join('');

        els.chapters.innerHTML = epub.chapters
          .map(ch => `<div class="chapter">${ch.content}</div>`)
          .join('');

        totalChapters = epub.chapters.length;
        
        // Default to book mode on load
        els.reader.classList.add('book-mode');
        els.chapters.classList.add('book-mode');
        document.querySelector('.nav-button.book').classList.add('active');
        convertToPages();
        
        showChapter(0);
        
        document.onkeydown = e => {
          if (e.key === 'ArrowRight') nextPage();
          if (e.key === 'ArrowLeft') prevPage();
        };
      } catch (err) {
        els.debug.textContent = `Error: ${err.message}`;
        console.error(err);
      }
    }

    // Update book mode toggle function
    function toggleBookMode() {
      const isBookMode = els.reader.classList.toggle('book-mode');
      els.chapters.classList.toggle('book-mode');
      document.querySelector('.nav-button.book').classList.toggle('active');
      
      if (isBookMode) {
        convertToPages();
      } else {
        restoreChapterView();
      }
      
      showChapter(currentChapter);
    }

    function convertToPages() {
      const chapters = [...els.chapters.children];
      const isMobileView = window.innerWidth <= 800;

      // Adjust mobile font size and spacing
      const mobileStyles = isMobileView ? `
      ` : `
      `;

      chapters.forEach((chapter, chapterIndex) => {
        chapter.style.display = 'block';
        chapter.style.visibility = 'hidden';
        
        const pageWidth = isMobileView ? chapter.clientWidth : chapter.clientWidth / 2;
        
        const measureDiv = document.createElement('div');
        measureDiv.style.cssText = `
          position: absolute;
          visibility: hidden;
          width: ${pageWidth}px;
          padding: ${isMobileView ? '20px' : '1.5em'};
          font-size: ${window.getComputedStyle(chapter).fontSize};
          line-height: ${window.getComputedStyle(chapter).lineHeight};
          box-sizing: border-box;
        `;
        document.body.appendChild(measureDiv);

        const content = chapter.innerHTML;
        const pages = [];
        let currentPageContent = '';
        const maxHeight = isMobileView ? 
          window.innerHeight - 80 : // Account for mobile padding/margins
          chapter.clientHeight - 24;

        // Filter out empty text nodes and preserve whitespace
        const elements = Array.from(new DOMParser()
          .parseFromString(content, 'text/html')
          .body.childNodes)
          .filter(node => 
            node.nodeType === Node.TEXT_NODE ? 
            node.textContent.trim().length > 0 : true
          );

        if (chapterIndex === 0) {
          // Title page - combine all content into a single centered page
          const titleContent = `
            <div class="title-page" style="
              display: flex;
              flex-direction: column;
              justify-content: center;
              align-items: center;
              min-height: 100%;
              text-align: center;
              padding: ${isMobileView ? '0em 1em' : '0em'};
              margin-top: ${isMobileView ? '0em' : '0'};
            ">
              ${elements.map(el => el.outerHTML || el.textContent).join('')}
            </div>
          `;
          pages.push(titleContent);
        } else {
          // Process regular chapter content
          elements.forEach(element => {
            const elementHTML = element.outerHTML || element.textContent;
            
            // Preserve whitespace when measuring
            measureDiv.style.whiteSpace = 'pre-wrap';
            measureDiv.innerHTML = currentPageContent + elementHTML;

            if (measureDiv.offsetHeight <= maxHeight) {
              currentPageContent += elementHTML;
            } else {
              if (currentPageContent.trim()) {
                pages.push(currentPageContent);
              }
              
              // Handle elements that are too large for a single page
              measureDiv.innerHTML = elementHTML;
              if (measureDiv.offsetHeight <= maxHeight) {
                currentPageContent = elementHTML;
              } else {
                // Split large elements if needed
                const words = elementHTML.split(/(\s+)/);
                let tempContent = '';
                
                for (const word of words) {
                  measureDiv.innerHTML = tempContent + word;
                  if (measureDiv.offsetHeight > maxHeight) {
                    if (tempContent.trim()) {
                      pages.push(tempContent);
                    }
                    tempContent = word;
                  } else {
                    tempContent += word;
                  }
                }
                
                currentPageContent = tempContent;
              }
            }
          });

          if (currentPageContent.trim()) {
            pages.push(currentPageContent);
          }
        }

        document.body.removeChild(measureDiv);

        // Only update chapter content if we have pages
        if (pages.length) {
          chapter.innerHTML = pages
            .map(content => `
              <div class="page" style="${mobileStyles}${chapterIndex !== 0 ? 'width: 100%; padding: 20px; text-align: justify;' : ''}">
                ${content}
              </div>
            `)
            .join('');
        }
      });

      // Restore visibility
      chapters.forEach(chapter => {
        chapter.style.display = '';
        chapter.style.visibility = '';
      });
    }

    function restoreChapterView() {
      const chapters = [...els.chapters.children];
      
      chapters.forEach(chapter => {
        // Get all pages content
        const pages = [...chapter.querySelectorAll('.page')];
        if (!pages.length) return;
        
        // Combine all page content and unwrap from page divs
        const content = pages.reduce((acc, page) => {
          // Extract content from page div and remove the div wrapper
          const pageContent = page.innerHTML;
          return acc + pageContent;
        }, '');
        
        // Remove all page divs and directly insert content
        chapter.innerHTML = content;
        
        // Reset chapter styles
        chapter.style = '';
        chapter.classList.remove('active');
      });
      
      // Reset reader styles
      els.reader.style = '';
      els.chapters.style = '';
      
      // Reset current page
      currentPage = 0;
    }

    // Auto-load test.epub on page load
    window.addEventListener('load', async () => {
      try {
        const spinner = document.getElementById('loading-spinner');
        spinner.style.display = 'flex';
        els.uploadArea.classList.add('hidden');
        
        const response = await fetch('https://ordinals.com/content/2d9cecf5e824625aa829835069323aa866d3270318e1edf77cd1be9438dd5323i0');
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const blob = await response.blob();
        await loadEpub(blob);
        
        // Match system dark mode preference
        const prefersLight = window.matchMedia('(prefers-color-scheme: light)').matches;
        document.body.classList.toggle('light', prefersLight);
        
        // Listen for system theme changes
        window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', e => {
          document.body.classList.toggle('light', e.matches);
        });

        spinner.style.display = 'none';
      } catch (err) {
        const spinner = document.getElementById('loading-spinner');
        spinner.style.display = 'none';
        els.uploadArea.classList.remove('hidden');
        els.debug.textContent = `Error loading .epub: ${err.message}`;
        console.error('Epub loading error:', err);
      }
    });

    // Update theme toggle function
    function toggleMenu() {
      const dropdown = document.querySelector('.menu-dropdown');
      const trigger = document.querySelector('.menu-trigger');
      dropdown.classList.toggle('active');
      trigger.classList.toggle('active');
      
      // Close menu when clicking outside
      const closeMenu = (e) => {
        if (!dropdown.contains(e.target) && !trigger.contains(e.target)) {
          dropdown.classList.remove('active');
          trigger.classList.remove('active');
          document.removeEventListener('click', closeMenu);
        }
      };
      
      if (dropdown.classList.contains('active')) {
        setTimeout(() => {
          document.addEventListener('click', closeMenu);
        }, 0);
      }
    }

    // Add a function to detect mobile devices
    function isMobile() {
      return window.innerWidth <= 1024;
    }

    // Modify scroll handling
    els.reader.onscroll = (e) => {
      if (isScrolling || isMobile()) return;

      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        const scrollPos = els.reader.scrollTop;
        const height = els.reader.clientHeight;
        const scrollPercent = scrollPos / (els.reader.scrollHeight - height);

        if (scrollPercent > 0.8 && currentChapter < totalChapters - 1) {
          showChapter(currentChapter + 1);
        } else if (scrollPercent < 0.2 && currentChapter > 0) {
          showChapter(currentChapter - 1);
        }
      }, 100);
    };</script></body></html>